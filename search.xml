<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[获取鼠标坐标的小工具开发]]></title>
      <url>http://yoursite.com/2016/07/14/%E8%8E%B7%E5%8F%96%E9%BC%A0%E6%A0%87%E5%9D%90%E6%A0%87%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>打算做一个自动化的工具，发现获取鼠标当前坐标的值有点麻烦，截图然后用Photoshop的标尺来查看太浪费时间了，于是写了个小工具用来获取坐标。用的是autopy这个库来实现功能，Tkinter来绘制界面。方便下一步进行其他的开发。<br><a id="more"></a></p>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p>当我们按下<strong>Enter</strong>或点击Print按钮的时候，如果上方输入框均为非空，就会将框内坐标打印到底下的文本框中，否则会打印当前鼠标顶点所在坐标。</p>
<p><img src="http://oa5cno1tg.bkt.clouddn.com//web/image/20160714/get_point_tool.png" alt=""></p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>可以快速记录下要使用的坐标为多少，方便之后进行自动化的处理。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>autopy是一个轻量级的跨平台Python库，主要有模拟按键及鼠标、处理颜色及图像等功能。其图像部分并不如PIL那么广为人知，自动化方面也不如pywin32那么出名。但其用法简单且不受平台限制，用来模拟点击十分好用。</p>
<p>Tkinter是Python自带的GUI库，布局粗糙，界面朴素，但其跨平台稳定，所以用在这种小工具上再合适不过了。相比之下，PyQt虽然界面丰富，在这种唱井下就则略显臃肿了。</p>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>首先安装autopy，在autopy的安装过程中可能会报如下错误:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error: command &apos;x86_64-linux-gnu-gcc&apos; failed with exit status 1</div></pre></td></tr></table></figure></p>
<p>解决办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libx11-dev libxtst-dev libpng-dev</div></pre></td></tr></table></figure></p>
<p>然后再安装即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install autopy</div></pre></td></tr></table></figure></p>
<p>安装完成之后，测试一下能否获取到坐标<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> autopy</div><div class="line"><span class="keyword">print</span> autopy.mouse.get_pos()</div></pre></td></tr></table></figure></p>
<p>现在开始编写GUI，并不复杂，直接贴代码了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> autopy</div><div class="line"><span class="keyword">from</span> Tkinter <span class="keyword">import</span> *</div><div class="line"></div><div class="line">master = Tk()</div><div class="line">master.title(<span class="string">"Get Point Tool"</span>)</div><div class="line"></div><div class="line"><span class="comment">#columnspan=2表示横跨两个column</span></div><div class="line">Label(master,text = <span class="string">"Press Enter to get New Point"</span>).grid(row = <span class="number">0</span>, columnspan = <span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment">#sticky=E表示向右对齐</span></div><div class="line">Label(master, text = <span class="string">'x = '</span>).grid(row = <span class="number">1</span>, sticky = E)</div><div class="line">Label(master, text = <span class="string">'y = '</span>).grid(row = <span class="number">2</span>, sticky = E)</div><div class="line"></div><div class="line">e1 = Entry(master)</div><div class="line">e2 = Entry(master)</div><div class="line">e1.grid(row = <span class="number">1</span>, column = <span class="number">1</span>, sticky = W)</div><div class="line">e2.grid(row = <span class="number">2</span>, column = <span class="number">1</span>, sticky = W)</div><div class="line"></div><div class="line"><span class="comment">#将坐标插入文本框</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_point</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">if</span>(e1.get()==<span class="string">""</span> <span class="keyword">or</span> e2.get()==<span class="string">""</span>):</div><div class="line">        text_output.insert(<span class="number">0.0</span>, str(autopy.mouse.get_pos())+<span class="string">"\n"</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        text_output.insert(<span class="number">0.0</span>, <span class="string">"("</span>+e1.get()+<span class="string">","</span>+e2.get()+<span class="string">")"</span> + <span class="string">"\n"</span>)</div><div class="line">        <span class="comment">#清空x、y两个文本框的值，delete(0,1000)表示删除第0位到第1000位的值</span></div><div class="line">        e1.delete(<span class="number">0</span>,<span class="number">1000</span>)</div><div class="line">        e2.delete(<span class="number">0</span>,<span class="number">1000</span>)</div><div class="line"></div><div class="line"></div><div class="line">Button(master, text = <span class="string">"Print"</span>, command = print_point).grid(row = <span class="number">3</span>, columnspan = <span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment">#将Return键与函数绑定，注意这里要用lambada</span></div><div class="line">master.bind(<span class="string">'&lt;Return&gt;'</span>,<span class="keyword">lambda</span> event:print_point())</div><div class="line"></div><div class="line">text_output = Text(master)</div><div class="line">text_output.grid(row = <span class="number">4</span>,columnspan = <span class="number">2</span>)</div><div class="line">text_output.config(width=<span class="number">30</span>)</div><div class="line"></div><div class="line"></div><div class="line">mainloop()  <span class="comment">#消息循环</span></div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用Python将文件隐藏于图片中]]></title>
      <url>http://yoursite.com/2016/07/11/%E4%BD%BF%E7%94%A8Python%E5%B0%86%E6%96%87%E4%BB%B6%E9%9A%90%E8%97%8F%E4%BA%8E%E5%9B%BE%E7%89%87%E4%B8%AD/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前些年网上曾流行过“图种”，将torrent文件隐藏在JPG图片之中，避开了对链接进行匹配的屏蔽。网上流传的多是rar格式，闲来试了试，zip也可以，查找了一些资料，将过程整理如下。<br><a id="more"></a></p>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p>将这张图右键保存，可以看到是一张后缀为JPG的图片</p>
<p><img src="http://oa5cno1tg.bkt.clouddn.com//web/image/20160711/before.jpg" alt=""></p>
<p>但重命名为以zip为后缀的压缩包后，会得到其他的文件</p>
<p><img src="http://oa5cno1tg.bkt.clouddn.com//web/image/20160711/screenshot_after_zip.png" alt=""></p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul>
<li><strong>轻度</strong>提高文件的安全性</li>
<li>规避大多数<strong>字符串</strong>屏蔽规则</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>JPG图片是二进制，其以0xFF,0xD8作为文件的SOI(Start Of Image)，以0xFF,0XD9作为文件的EOI(End Of Image)。详细结构见<a href="https://en.wikipedia.org/wiki/JPEG#Syntax_and_structure" target="_blank" rel="external">wiki</a></p>
<p>以图片begin.JPG为例，我们可以用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexdump -C before.JPG | head</div></pre></td></tr></table></figure></p>
<p>以及<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexdump -C before.JPG | tail</div></pre></td></tr></table></figure></p>
<p>来查看其二进制值<br><img src="http://oa5cno1tg.bkt.clouddn.com//web/image/20160711/before_binary_head_and_%20tail.png" alt=""></p>
<p>同理，我们查看zip文件的二进制值，其Local file header Signature与End of central directory record Signature分别为0x504b0304和0x504b0506，详细结构见<a href="https://users.cs.jmu.edu/buchhofp/forensics/formats/pkzip.html" target="_blank" rel="external">这里</a></p>
<p><img src="http://oa5cno1tg.bkt.clouddn.com//web/image/20160711/zip_binary_head_and_%20tail.png" alt=""></p>
<p>我们将两个二进制文件拼接成一个，因JPG格式必须以特殊标识作为文件头，zip与rar等只需要包含特殊标识即可，因此生成的文件冠以不同后缀时，可作为不同文件格式使用。这种文件又称之为Poyglot,引用<a href="https://en.wikipedia.org/wiki/Polyglot_(computing)" target="_blank" rel="external">wiki</a>上的定义：</p>
<blockquote>
<p>In computing, a polyglot is a computer program or script written in a valid form of multiple programming languages, which performs the same operations or output independent of the programming language used to compile or interpret it.</p>
</blockquote>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>本文实验环境：</p>
<ol>
<li>linux操作系统（如deepin）</li>
<li>python 2.7.x</li>
<li>一张标准JPG图片（如before.JPG）</li>
<li>一个txt文件（test.txt）</li>
</ol>
<p>要实现这个功能，方法多种多样，甚至一行代码如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat test.zip &gt;&gt; before.JPG</div></pre></td></tr></table></figure></p>
<p>都可以实现。但现在我们可以使用Python，进行更多的探索。</p>
<p>步骤：</p>
<ol>
<li>将txt文件转换为zip文件</li>
<li>读取zip文件与JPG文件</li>
<li>拼接读取到的二进制值，写入新生成的JPG文件</li>
</ol>
<p>首先，生成zip文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> zipfile</div><div class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">'test.zip'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f_zip:</div><div class="line">    f_zip.write(<span class="string">'test.txt'</span>)</div></pre></td></tr></table></figure></p>
<p>然后读取zip文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">'test.zip'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</div><div class="line">    data_txt = f.read()</div></pre></td></tr></table></figure></p>
<p>同理，读取JPG文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">'before.JPG'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</div><div class="line">    data_JPG = f.read()</div></pre></td></tr></table></figure></p>
<p>最后，写入新的JPG<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">'after.JPG'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</div><div class="line">    data = data_JPG + data_txt</div><div class="line">    f.write(data)</div></pre></td></tr></table></figure></p>
<p>最后，删除生成的zip文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line">os.remove(<span class="string">'test.zip'</span>)</div></pre></td></tr></table></figure></p>
<p>这样，便将txt文件成功藏入JPG文件之中了。</p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>在生成zip文件时候，可以写入多个文件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> zipfile</div><div class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">'test.zip'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f_zip:</div><div class="line">    f_zip.write(<span class="string">'test.txt'</span>)</div><div class="line">    f_zip.write(<span class="string">'test1.txt'</span>)</div></pre></td></tr></table></figure></p>
<p>zipfile也支持在打包成zip的同时进行压缩<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> zipfile.ZipFile(<span class="string">'test.zip'</span>, <span class="string">'w'</span>,zipfile.ZIP_DEFLATED) <span class="keyword">as</span> f_zip:</div><div class="line">    f_zip.write(<span class="string">'test.txt'</span>)</div></pre></td></tr></table></figure></p>
<p>如果需要压缩一整个文件夹，可以用glob遍历文件夹里的文件名,生成列表<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> glob</div><div class="line">files = glob.glob(filepath)</div></pre></td></tr></table></figure></p>
<p>之所以选择zip，是因为Python对zip原生支持，如果要用rar也可以，可以选择rarfile或者其他第三方模块即可。</p>
]]></content>
    </entry>
    
  
  
</search>
